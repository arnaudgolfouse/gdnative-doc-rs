mod config;
mod markdown;

pub use config::Config;
pub use markdown::MarkdownCallbacks;

use crate::documentation::{Documentation, Method, Type};
use pulldown_cmark::{Alignment, CowStr, Event, LinkType, Parser, Tag};

/// Generate a callback to resolve broken links.
///
/// We have to generate a new one for each use because the lifetimes on
/// `pulldown_cmark::Parser::new_with_broken_link_callback` are not yet
/// refined enough.
macro_rules! broken_link_callback {
    ($config:expr) => {
        move |broken_link: ::pulldown_cmark::BrokenLink| {
            use ::pulldown_cmark::CowStr;

            let mut link = broken_link.reference;
            if link.starts_with('`') && link.ends_with('`') && link.len() > 1 {
                link = &link[1..link.len() - 1];
            }
            $config
                .resolve(link)
                .map(|string| (CowStr::from(string), CowStr::Borrowed("")))
        }
    };
}

/// Kind of files generated by the crate
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum Backend {
    Markdown,
    Html,
}

impl Backend {
    /// File extension
    pub fn extension(self) -> &'static str {
        match self {
            Self::Markdown => "md",
            Self::Html => "html",
        }
    }
}

/// Callbacks to encode markdown input in a given format.
pub trait Callbacks {
    fn start_encoding(&mut self, s: &mut String, config: &Config, documentation: &Documentation);
    /// Encode the stream of `events` in `s`.
    fn encode(&mut self, s: &mut String, events: Vec<Event<'_>>);
    /// Called at the end of the processing for a given file.
    fn finish_encoding(&mut self, s: &mut String);
}

/// Implementation of [`Callbacks`] for html.
#[derive(Default)]
pub struct HtmlCallbacks {}

impl Callbacks for HtmlCallbacks {
    fn start_encoding(
        &mut self,
        _s: &mut String,
        _config: &Config,
        _documentation: &Documentation,
    ) {
    }
    fn encode(&mut self, s: &mut String, events: Vec<Event<'_>>) {
        pulldown_cmark::html::push_html(s, events.into_iter())
    }
    fn finish_encoding(&mut self, _s: &mut String) {}
}

/// Generate files given an encoding
pub struct Generator<'a> {
    /// Configuration, mainly used to resolve links.
    config: &'a Config,
    /// Encoding functions.
    callbacks: Box<dyn Callbacks>,
    /// Data to encode.
    documentation: &'a Documentation,
}

impl<'a> Generator<'a> {
    pub fn new(
        config: &'a Config,
        documentation: &'a Documentation,
        callbacks: Box<dyn Callbacks>,
    ) -> Self {
        Self {
            config,
            callbacks,
            documentation,
        }
    }

    /// Generate the root documentation file of the crate.
    pub fn generate_root_file(&mut self, backend: Backend) -> String {
        let mut root_file = String::new();
        let config = self.config;
        let mut broken_link_callback = broken_link_callback!(config);
        let class_iterator = EventIterator {
            context: config,
            parser: pulldown_cmark::Parser::new_with_broken_link_callback(
                &self.documentation.root_documentation,
                self.config.markdown_options,
                Some(&mut broken_link_callback),
            ),
        };
        let mut events: Vec<_> = class_iterator.into_iter().collect();
        events.extend(vec![
            Event::Start(Tag::Heading(1)),
            Event::Text(CowStr::Borrowed("Classes:")),
            Event::End(Tag::Heading(1)),
            Event::Start(Tag::List(None)),
        ]);
        for (class_name, _) in &self.documentation.classes {
            let link = Tag::Link(
                LinkType::Inline,
                format!("./{}.{}", class_name, backend.extension()).into(),
                CowStr::Borrowed(""),
            );
            events.extend(vec![
                Event::Start(Tag::Item),
                Event::Start(link.clone()),
                Event::Text(CowStr::Borrowed(&class_name)),
                Event::End(link.clone()),
                Event::End(Tag::Item),
            ])
        }
        events.push(Event::End(Tag::List(None)));
        self.callbacks.encode(&mut root_file, events);
        self.callbacks.finish_encoding(&mut root_file);
        root_file
    }

    /// Generate pairs of (class_name, file_content).
    pub fn generate_files(&mut self) -> Vec<(String, String)> {
        let mut results = Vec::new();
        for (name, class) in &self.documentation.classes {
            let mut class_file = String::new();

            self.callbacks
                .start_encoding(&mut class_file, &self.config, &self.documentation);
            let callbacks = &mut self.callbacks;
            let mut encode = |events| callbacks.encode(&mut class_file, events);
            let inherit_link = self.config.resolve(&class.inherit);

            // Name of the class + inherit
            let mut events = vec![
                Event::Start(Tag::Heading(1)),
                Event::Text(CowStr::Borrowed(&name)),
                Event::End(Tag::Heading(1)),
                Event::Start(Tag::Paragraph),
                Event::Start(Tag::Strong),
                Event::Text(CowStr::Borrowed("Inherit:")),
                Event::End(Tag::Strong),
                Event::Text(CowStr::Borrowed(" ")),
            ];
            if let Some(inherit_link) = inherit_link.as_ref() {
                events.extend(vec![
                    Event::Start(Tag::Link(
                        LinkType::Shortcut,
                        CowStr::Borrowed(&inherit_link),
                        CowStr::Borrowed(""),
                    )),
                    Event::Text(CowStr::Borrowed(&class.inherit)),
                    Event::End(Tag::Link(
                        LinkType::Shortcut,
                        CowStr::Borrowed(&inherit_link),
                        CowStr::Borrowed(""),
                    )),
                ])
            } else {
                events.push(Event::Text(CowStr::Borrowed(&class.inherit)))
            }
            events.extend(vec![
                Event::End(Tag::Paragraph),
                Event::Start(Tag::Heading(2)),
                Event::Text(CowStr::Borrowed("Description")),
                Event::End(Tag::Heading(2)),
            ]);
            encode(events);

            // Class description
            let config = self.config;
            let mut broken_link_callback = broken_link_callback!(config);
            let class_documentation = EventIterator {
                context: config,
                parser: pulldown_cmark::Parser::new_with_broken_link_callback(
                    &class.documentation,
                    config.markdown_options,
                    Some(&mut broken_link_callback),
                ),
            };
            encode(class_documentation.into_iter().collect());

            // Methods table
            let mut events = vec![
                Event::Start(Tag::Heading(2)),
                Event::Text(CowStr::Borrowed("Methods")),
                Event::End(Tag::Heading(2)),
                Event::Start(Tag::Table(vec![Alignment::Left, Alignment::Left])),
                Event::Start(Tag::TableHead),
                Event::Start(Tag::TableCell),
                Event::Text(CowStr::Borrowed("returns")),
                Event::End(Tag::TableCell),
                Event::Start(Tag::TableCell),
                Event::Text(CowStr::Borrowed("method")),
                Event::End(Tag::TableCell),
                Event::End(Tag::TableHead),
            ];
            encode(std::mem::take(&mut events));

            for method in &class.methods {
                let link = Self::link(method);
                encode(vec![
                    Event::Start(Tag::TableRow),
                    Event::Start(Tag::TableCell),
                ]);
                encode(Self::encode_type(config, &method.return_type));
                encode(vec![
                    Event::End(Tag::TableCell),
                    Event::Start(Tag::TableCell),
                ]);

                let link = Tag::Link(
                    LinkType::Reference,
                    link.into(),
                    method.name.as_str().into(),
                );
                encode(vec![
                    Event::Start(link.clone()),
                    Event::Text(CowStr::Borrowed(&method.name)),
                    Event::End(link),
                    Event::Text(CowStr::Borrowed("( ")),
                ]);
                for (index, (name, typ, _)) in method.parameters.iter().enumerate() {
                    encode(vec![Event::Text(format!("{}: ", name).into())]);
                    encode(Self::encode_type(config, typ));
                    if index + 1 != method.parameters.len() {
                        encode(vec![Event::Text(CowStr::Borrowed(", "))]);
                    }
                }

                encode(vec![
                    Event::Text(CowStr::Borrowed(" )")),
                    Event::End(Tag::TableCell),
                    Event::End(Tag::TableRow),
                ]);
            }

            events.extend(vec![
                Event::End(Tag::Table(vec![Alignment::Left, Alignment::Left])),
                Event::Start(Tag::Heading(2)),
                Event::Text(CowStr::Borrowed("Methods Descriptions")),
                Event::End(Tag::Heading(2)),
            ]);

            encode(events);

            // Methods
            for method in &class.methods {
                //self.generate_method(&mut class_file, method);
                let callbacks = &mut self.callbacks;
                Self::generate_method(
                    |events| callbacks.encode(&mut class_file, events),
                    config,
                    method,
                )
            }
            self.callbacks.finish_encoding(&mut class_file);
            results.push((name.clone(), class_file))
        }
        results
    }

    /// Encode the documentation for `method`.
    fn generate_method(mut encode: impl FnMut(Vec<Event>), config: &Config, method: &Method) {
        let link = &format!("<a id=\"func-{}\"></a>", method.name);
        encode(vec![
            Event::Start(Tag::Heading(3)),
            Event::Html(CowStr::Borrowed(link)),
        ]);
        let mut method_section = String::from("func ");
        method_section.push_str(&method.name);
        method_section.push('(');
        for (index, (name, typ, _)) in method.parameters.iter().enumerate() {
            method_section.push_str(&name);
            method_section.push_str(": ");
            encode(vec![Event::Text(CowStr::Borrowed(&method_section))]);
            method_section.clear();
            encode(Self::encode_type(config, typ));
            if index + 1 != method.parameters.len() {
                method_section.push_str(", ");
            }
        }
        method_section.push_str(") -> ");
        encode(vec![Event::Text(CowStr::Borrowed(&method_section))]);

        encode(Self::encode_type(config, &method.return_type));

        encode(vec![Event::End(Tag::Heading(3)), Event::Rule]);
        let config = config;
        let mut broken_link_callback = broken_link_callback!(config);
        let method_iterator = EventIterator {
            context: config,
            parser: pulldown_cmark::Parser::new_with_broken_link_callback(
                &method.documentation,
                config.markdown_options,
                Some(&mut broken_link_callback),
            ),
        };
        encode(method_iterator.into_iter().collect());
    }

    /// Encode a type with it's link.
    fn encode_type<'b>(config: &'b Config, typ: &'b Type) -> Vec<Event<'b>> {
        let (type_name, optional) = match typ {
            Type::Option(typ) => (typ.as_str(), true),
            Type::Named(typ) => (typ.as_str(), false),
            Type::Unit => ("void", false),
        };
        let mut events = match config.resolve(type_name).map(|return_link| {
            Tag::Link(
                LinkType::Shortcut,
                CowStr::Borrowed(&return_link),
                CowStr::Borrowed(""),
            )
        }) {
            Some(link) => {
                vec![
                    Event::Start(link.clone()),
                    Event::Text(CowStr::Borrowed(type_name)),
                    Event::End(link),
                ]
            }
            None => {
                vec![Event::Text(CowStr::Borrowed(type_name))]
            }
        };
        if optional {
            events.push(Event::Text(CowStr::Borrowed(" (opt)")))
        }
        events
    }

    /// Returns a suitable markdown representation of this method to link to if the
    /// method were to be put in a section title.
    fn link(method: &Method) -> String {
        format!("#func-{}", method.name)
    }
}

/// Iterate over [events](Event), resolving links and changing the resolved
/// broken links types.
struct EventIterator<'config, 'parser> {
    context: &'config Config,
    parser: Parser<'parser>,
}

impl<'config, 'parser> Iterator for EventIterator<'config, 'parser> {
    type Item = Event<'parser>;

    fn next(&mut self) -> Option<Self::Item> {
        let mut next_event = self.parser.next()?;
        next_event = match next_event {
            // matches broken reference links that have been restored by the callback
            // and replaces them by shortcut variants
            Event::Start(Tag::Link(LinkType::ShortcutUnknown, dest, title)) => {
                Event::Start(Tag::Link(LinkType::Shortcut, dest, title))
            }
            Event::End(Tag::Link(LinkType::ShortcutUnknown, dest, title)) => {
                Event::End(Tag::Link(LinkType::Shortcut, dest, title))
            }
            _ => next_event,
        };
        self.context.resolve_event(&mut next_event);
        Some(next_event)
    }
}
